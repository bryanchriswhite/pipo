<!doctype html>
<html>
  <head>
    <title>PiPo</title>
  </head>
  <body>
    <div id="mainContainer">
      <ul id="messages">
      </ul>
      <div id="menu">
        <div id="left-menu-profile">
          <div id="menu-header-profile">
            <div class="ui teal buttons">
              <div class="ui button">Options</div>
              <div class="ui floating dropdown icon button">
                <i class="chevron down icon"></i>
                <div id="options-menu-dropdown" class="menu">
                  <div class="ui icon search input">
                    <i class="search icon"></i>
                    <input type="text" name="search" placeholder="Search messages...">
                  </div>
                  <div id="generate-keypair-button" class="item"><i class="spy icon"></i> Generate new client key pair</div>
                  <div id="select-keypair-button" class="item"><i class="folder open icon"></i> Select existing key pair</div>
                  <div id="export-keypair-button" class="item"><i class="download icon"></i> Export client key pair</div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div id="left-menu-scroll">
          <div class="room-list-container">
            <h5 class="room-list-header">Rooms</h5>
            <ul id="room-list">
              <li class="room-list-item">#general</li>
            </ul>
          </div>
          <div class="user-list-container">
            <h5 class="user-list-header">Users</h5>
            <div id="user-list">
            </div>
          </div>
        </div>
        <div id="menu-actions">
        </div>
      </div>
    </div>

    <div class="input-container" id="input-container">
      <form>
        <div id="message-input-container" class="ui left fluid action icon input loading">
          <textarea id="message-input" class="message-input ui left icon loading" autocorrect="off" spellcheck="true" autocomplete="off" type="text" placeholder="          Please wait while your secure connection is configured..."></textarea>
          <i id="loading-icon" class="search icon"></i>
          <button id="send-button" class="ui button" disabled="true">Send</button>
        </div>
      </form>
    </div>

    <div class="ui form basic modal password-prompt-modal">
      <i class="close icon"></i>
      <div class="header">
        Decrypt Master Key
      </div>
      <div class="ui">
        <div class="description">
          <p>Please enter your client key password...</p>
        </div>
        <div class="ui input">
            <input name="password" type="password" placeholder="password"></input>
        </div>
      </div>
      <div class="actions">
        <div class="two fluid ui inverted buttons">
          <div class="ui red basic inverted button">
            <i class="remove icon"></i>
            Cancel
          </div>
          <div class="ui green basic inverted button password-submit-button">
            <i class="checkmark icon"></i>
            Ok
          </div>
        </div>
      </div>
    </div>

    <div class="ui form basic modal key-creds-modal">
      <i class="close icon"></i>
      <div class="header">
        Enter your key information
      </div>
      <div class="ui">
        <div class="description">
          <p>Username:</p>
        </div>
        <div class="ui input">
            <input name="username" type="username" placeholder="User Name"></input>
        </div>
                  <div class="description">
          <p>Full Name:</p>
        </div>
        <div class="ui input">
            <input name="fullname" type="fullname" placeholder="Full Name"></input>
        </div>
                  <div class="description">
          <p>Email:</p>
        </div>
        <div class="ui input">
            <input name="email" type="email" placeholder="Email"></input>
        </div>
        <div class="description">
          <p>Please enter a strong password:</p>
        </div>
      </div>
      <div class="actions">
        <div class="two fluid ui inverted buttons">
          <div class="ui red basic inverted button">
            <i class="remove icon"></i>
            Cancel
          </div>
          <div class="ui green basic inverted button key-creds-submit-button">
            <i class="checkmark icon"></i>
            Ok
          </div>
        </div>
      </div>
    </div>

    <div class="ui form basic modal import-keypair-modal">
      <i class="close icon"></i>
      <div class="header">
        Import Client Key Pair
      </div>
      <div class="ui">
        <div class="description">
          <p>Please locate your keys...</p>
        </div>
        <div class="ui">
          <a href="#" id="select-pubkey">Public Key: </a><input type="file" id="pubkey-file-input"></input>
        </div>
        <div class="ui">
          <a href="#" id="select-privkey">Private Key: </a><input type="file" id="privkey-file-input"></input>
        </div>
      </div>
      <div class="actions">
        <div class="two fluid ui inverted buttons">
          <div class="ui red basic inverted button">
            <i class="remove icon"></i>
            Cancel
          </div>
          <div class="ui green basic inverted button import-keypair-submit-button">
            <i class="checkmark icon"></i>
            Ok
          </div>
        </div>
      </div>
    </div>

    <link rel="stylesheet" href="/css/semantic.css">
    <link rel="stylesheet" href="/css/pipo.css">
    <link rel="stylesheet" href="/css/highlight.js/styles/default.css">

    <script src="/js/openpgp.js"></script>
    <script src="http://code.jquery.com/jquery-1.11.1.js"></script>
    <script src="/js/semantic.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script src="js/marked.js"></script>

<script src="https://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

    <script>
      marked.setOptions({
        renderer: new marked.Renderer(),
        gfm: true,
        tables: true,
        breaks: true,
        pedantic: false,
        sanatize: true,
        smartLists: true,
        smartypants: false,
        highlight: function (code) {
          return hljs.highlightAuto(code).value;
        }
      });
      var host = window.location.host;
      var socket = io(host+'/main');
      var currentChannel = "general";
      var clientKeyPassword = null;
      var masterKeyPassword = 'pipo';
      var amountOfSpaceNeeded = 5000000;
      var keyPair = ({
        pubKey: null,
        privKey: null
      });
      var encryptedMasterKeyPair = ({
        pubKey: null,
        privKey: null
      });
      var masterKeyPair = ({
        pubKey: null,
        privKey: null
      });
      var userName = null;
      function start() {
        console.log("Starting!");
        //if (isHidden()) notify('test', 'test notification here', '123123');
        openpgp.initWorker('/js/openpgp.worker.js');

        // This should use localMsg
        //var statusType = "STATUS";
        //var statusMessage = "Please wait while your keys are prepared...";
        //$('#messages').append($('<li>').text("["+statusType+"] "+statusMessage));
        //localMsg({ type: "STATUS", message: "Please wait while your keys are prepared..." });
        pleaseWait();
        initStorage(function(err, fs) {
          console.log("in initStorage callback");
          if (err) { return console.log("[START][STORAGE] Error during init storage: "+err); };
          getUserName(function(err, savedUserName) {
            userName = savedUserName;
            console.log("[START] Starting with username '"+userName+"'");
            loadClientKeyPair(fs, function(err) {
              console.log("[START] Sending init to server...");
              socket.emit('authenticate', { userName: userName });
              if (err) { return console.log("[START][LOAD CLIENT KEY] Error loading client key from local storage: "+err); };
              localMsg({ type: "STATUS", message: "Loaded client keys from local storage" });
              promptForPassword(function(err, password) {
                clientKeyPassword = password;
                updateRemotePubKey(userName, keyPair.pubKey, function(err) {
                  console.log("Remote keyPair check done.");
                  if (err) {
                    console.log("Error when checking for remote public key: "+err);
                    callback(err, null);
                  } else {
                    console.log("[START] Joining channel #general");
                    socket.emit('join', { userName: userName, channel: "general" } );
                    console.log("Update remote pub key done...");
                    updateMasterKey(function(err) {
                      if (err) { return console.log("Error: "+err); };
                      console.log("Turning pleaseWait off");
                      pleaseWaitOff();
                      $('#message-input').focus();
                    });
                  };
                });
              });
            });
          });
        });
      };

      socket.on('connect', function(e) {
        start();
        console.log("Got socket connect");
      });

      function setUserName(userName, callback) {
        localStorage.setItem("userName", userName);
        return callback(null);
      }

      function getUserName(callback) {
        var userName = localStorage.getItem("userName");
        return callback(null, userName);
      };

      function generateClientKeyPair(data, callback) {
        var password = data.password;
        var userName = data.userName;
        var email = data.email;
        var fullName = data.fullName;
        console.log("[DEBUG] Generating client key pair with - password: "+password+" userName: "+userName+" email: "+email+" fullName: "+fullName);
        generateKeyPair(2048, userName, password, function(err, generatedKeyPair) {
          if (err) {
            console.log("Error generating client keypair: "+err);
          } else {
            console.log("Generated client key pair.");
            localMsg({ type: "STATUS", message: "Client keys generated" });
            keyPair = generatedKeyPair;
            localMsg({ type: "STATUS", message: "Waiting for MASTER key from server..." });
            updateRemotePubKey("<%= userName %>", keyPair.pubKey, function(err) {
              console.log("Remote keyPair check done.");
              if (err) {
                console.log("Error when checking for remote public key: "+err);
                callback(err, null);
              } else {
                console.log("Update remote pub key done...");
              // Get master key if we don't have it locally
                //socket.emit('join', { userName: userName, channel: "general" } );
                socket.emit('regen master key');
                callback(null, generatedKeyPair);
              };
            });
          }
        });
      };

      function loadClientKeyPair(fs, callback) {
        console.log('Opened file system: ' + fs.name);
        getUserName(function(err, userName) {
          if (userName == null) {
            promptForKeyCredentials(function(err, data) {
              setUserName(data.userName, function(err) {
                updateUserData(data, function(err) {
                  if (err) { return callback(err) };
                });
              });
            });
          } else {
            console.log("User data updated");
            console.log('Attempting to open file: '+userName+'_clientkey.aes');
            fs.root.getFile(userName+'_clientkey.aes', {create: false, exclusive: true}, function(fileEntry) {
              fileEntry.file(function(file) {
                 var reader = new FileReader();
                 reader.onloadend = function(e) {
                  keyPair.privKey = this.result;

                  console.log('Attempting to open file: '+userName+'_clientkey.pub');
                  fs.root.getFile(userName+'_clientkey.pub', {create: false, exclusive: true}, function(fileEntry) {
                    fileEntry.file(function(file) {
                       var reader = new FileReader();
                       reader.onloadend = function(e) {
                        keyPair.pubKey = this.result;
                        return callback(null);
                       };
                       reader.readAsText(file);
                    }, loadClientKeyPairErrorHandler);
                  }, loadClientKeyPairErrorHandler);

                 };
                 reader.readAsText(file);
              }, loadClientKeyPairErrorHandler);
            }, loadClientKeyPairErrorHandler);
            // TODO: this is getting called, is that ok?
            return callback("Reached loadClientKeyPair callback bad...");
            function loadClientKeyPairErrorHandler(e) {
              var msg = '';
              console.log("[LOAD CLIENT KEY PAIR ERROR HANDLER] e.name: "+e.name+" e.message: "+e.message);
              console.log("[LCKPEH] FileError.NOT_FOUND_ERR: "+FileError.NOT_FOUND_ERR);
              switch (e.name) {
                case FileError.QUOTA_EXCEEDED_ERR:
                  msg = 'QUOTA_EXCEEDED_ERR';
                  break;
                case "NotFoundError":
                  console.log("Client keys not found in storage. Generating new keypair.");
                  msg = 'NOT_FOUND_ERR';
                  // TODO: Should allow user to choose to load their own key, or generate one

                  // TODO: Prompt for username

                  // TODO: If user has userdata and no client key, prompt to load own key or generate new one

                  // TODO: If no user data present on server, prompt for key credentials (should probably call user data) then prompt to load or gen key
                  promptForKeyCredentials(function(err, data) {
                    console.log("Data: "+data);
                    var userName = data.userName;
                    var fullName = data.fullName;
                    var email = data.email;
                    //console.log("Got data: userName: "+userName+" fullName: "+fullName+" email: "+email+" password: "+password);
                    // TODO: This should probably be cached in the clientKey object
                    //clientKeyPassword = password;
                    setUserName(userName, function(err) {
                      updateUserData(data, function(err) {
                        if (err) {
                          console.log("Error updating user data on server");
                        } else {
                          pleaseWait();
                          generateClientKeyPair(data, function(err, keyPair) {
                            saveClientKeyPair(fs, keyPair, userName, function(err) {
                              if (err) { console.log("Error generating client key pair: "+err); }
                              console.log("Saved client key pair locally");
                              callback(null);
                            });
                          });
                        };
                      });
                    });
                  });
                  break;
                case FileError.SECURITY_ERR:
                  msg = 'SECURITY_ERR';
                  break;
                case FileError.INVALID_MODIFICATION_ERR:
                  msg = 'INVALID_MODIFICATION_ERR';
                  break;
                case FileError.INVALID_STATE_ERR:
                  msg = 'INVALID_STATE_ERR';
                  break;
                default:
                  msg = 'Unknown Error';
                  break;
              };
              console.log('Error: ' + msg);
            };
          };
        });
      };

      function loadClientKeyPairFromFile(data, callback) {
        console.log("Loading client keypair from file: data.pubKey: "+data.pubKey+" data.privKey: "+data.privKey);
        initStorage(function(err, fs) {
          saveClientKeyPair(fs, keyPair, userName, function(err) {
            if (err) {
              callback(err);
            } else {
              callback(null);
            };
          });
        });
      };

      function updateUserData(data, callback) {
        var userName = data.userName;
        var fullName = data.fullName;
        var email = data.email;

        // TODO: do AJAX call to POST /user/data and push user data
        callback(null);
      };

      function removeClientKeyPair(fs, callback) {
        fs.root.getFile('clientkey.aes', {create: false}, function(fileEntry) {
          fileEntry.remove(function() {
            console.log('File successufully removed.');
            fs.root.getFile('clientkey.pub', {create: false}, function(fileEntry) {
              fileEntry.remove(function() {
                console.log('File successufully removed.');
                callback(null);
              }, errorHandler);
            }, errorHandler);
          }, errorHandler);
        }, errorHandler);
        function errorHandler(err) {
          var msg = '';
          switch(err.name) {
            case "BAD":
              console.log("Bad");
              return callback(err.message);
            default:
              message = 'Unknown Error: '+err.name;
              return callback(err.message);
          };
          console.log("Error: "+message);
        };
      };

      function regenerateClientKeyPair(callback) {
        initStorage(function(err, fs) {
          if (err) { return callback(err); };
          removeClientKeyPair(fs, function() {
            // Generate new key pair
            promptForKeyCredentials(function(err, data) {
              var password = data.password;
              var userName = data.userName;
              var email = data.email;
              var fullName = data.fullName;
              generateClientKeyPair(data, function(err, keyPair) {
                saveClientKeyPair(fs, keyPair, userName, function(err) {
                  if(err) { return console.log("Error regenerating client key pair: "+err); };
                  callback(null);
                });
              });
            });
          });
        });
      };

      function saveClientKeyPair(fs, keyPair, userName, callback) {
        var privKey = keyPair.privKey;
        var pubKey = keyPair.pubKey;
        fs.root.getFile(userName+'_clientkey.aes', {create: true}, function(fileEntry) {
          // Create a FileWriter object for our FileEntry (log.txt).
          fileEntry.createWriter(function(fileWriter) {
            fileWriter.onwriteend = function(e) {
              console.log('Client secret key write completed.');
              fs.root.getFile(userName+'_clientkey.pub', {create: true}, function(fileEntry) {
                // Create a FileWriter object for our FileEntry (log.txt).
                fileEntry.createWriter(function(fileWriter) {
                  fileWriter.onwriteend = function(e) {
                    console.log('Client public key write completed.');
                    return callback(null);
                  };
                  fileWriter.onerror = function(e) {
                    console.log('Write failed: ' + e.toString());
                  };
                  // Create a new Blob and write it to log.txt.
                  var blob = new Blob([pubKey], {type: 'text/plain'});
                  fileWriter.write(blob);
                }, errorHandler);
              }, errorHandler);
            };
            fileWriter.onerror = function(e) {
              console.log('Write failed: ' + e.toString());
            };
            // Create a new Blob and write it to log.txt.
            var blob = new Blob([privKey], {type: 'text/plain'});
            fileWriter.write(blob);
          }, errorHandler);
        }, errorHandler);
        function errorHandler(err) {
          var msg = '';
          switch(err.name) {
            case "BAD":
              console.log("Bad");
            default:
              message = 'Unknown Error: '+err.name;
          };
          console.log("Error: "+message);
        };
      }


      function initStorage(callback) {
        //Taking care of the browser-specific prefix
        window.requestFileSystem  = window.requestFileSystem || window.webkitRequestFileSystem;
        window.requestFileSystem(window.PERSISTENT, 1024*1024,onInitFs, function(err) {
          console.log("Error initStorage: "+err);
        });
        function onInitFs(fs) {
          console.log("[INIT STORAGE] Initializing storage...");
          // First check how much we can use in the Persistent storage.
          fs = fs;
          navigator.webkitPersistentStorage.queryUsageAndQuota(
            function (usage, quota) {
              var availableSpace = quota - usage;
              console.log("availableSpace: "+availableSpace);
              if (availableSpace >= amountOfSpaceNeeded) {
                console.log("Have as much space as we need!");
                return callback(null, fs);
              }
              var requestingQuota = amountOfSpaceNeeded + usage;
              navigator.webkitPersistentStorage.requestQuota(
                  requestingQuota,
                  function (grantedQuota) {
                    console.log("Didn't have enough space so requested more. Got: "+grantedQuota);
                    return callback(null, fs)
                  },
                  onError);
            }, onError
          );
          function onError(err) {
            console.log("Got error during init storage: "+err);
            callback(err);
          }
        };
      };


      function decryptMasterKey(userName, privKey, encryptedMasterPrivateKey, callback) {
        var encMasterPrivateKey = openpgp.message.readArmored(encryptedMasterPrivateKey);
        var clientPrivKey = openpgp.key.readArmored(privKey).keys[0];
        clientPrivKey.decrypt(clientKeyPassword);
        //console.log("[DEBUG] (decryptMasterKey) values - userName: "+userName+" privKey: "+clientPrivKey+" encMasterPrivateKey: "+encMasterPrivateKey);
        console.log("[DEBUG] about to start decrypting master key");
        //console.log("[DEBUG] encryptedMasterPrivateKey is: "+encryptedMasterPrivateKey);
        //console.log("[DEBUG] decrypting master private key and client public key is: "+keyPair.pubKey);
        //console.log("[DEBUG] decrypting master private key and client private key is: "+keyPair.privKey);

        openpgp.decryptMessage(clientPrivKey, encMasterPrivateKey).then(function(decryptedKey) {
          console.log("[DEBUG] in decryptMessage callback");
          //console.log("decrypted key in decryptMaster Key is: "+decryptedKey);
          callback(null, decryptedKey);
        }).catch(function(err) {
          console.log("[DEBUG] error decrypting message: "+err);
          if (err) { callback(err, null); };
        });
      };

      function getMasterKeyPair(userName, callback) {
        var timestamp = new Date().toString();
        console.log("["+timestamp+"] Getting master keyPair for "+userName);
        $.ajax({
          type: "GET",
          url: "/key/masterKeyPair",
          dataType: "json",
          data: {
            userName: userName
          },
          statusCode: {
            404: function(err) {
              console.log("["+timestamp+"] [MASTER KEY PAIR] (404) Error getting master keypair: "+err);
              return callback(err, null);
            },
            200: function(data) {
              console.log("["+timestamp+"] [MASTER KEY PAIR] (200) Encrypted masterKeyPair retrieved and cached");
              return callback(null, data);
            }
          }
        });
      };

      function updateRemotePubKey(userName, pubKey, callback) {
        console.log("Updating remote public key");
        $.ajax({
          type: "GET",
          url: "/key/pubkey",
          dataType: "json",
          data: {
            userName: userName
          },
          statusCode: {
            404: function(err) {
              console.log("No key found on remote");
              updatePubKeyOnRemote(userName, keyPair.pubKey, function(err) {
                console.log("1 Updating public key on remote");
                if (err) {
                  console.log("Error updating pubKey on remote");
                  return callback(err);
                } else {
                  console.log("Updated remote pubKey");
                    return callback(null);
                }
              });
            },
            200: function(data) {
              //console.log("[DEBUG] (updateRemotePubKey) data: "+data);
              var remotePubKey = data.pubKey;
              console.log("Key exists on remote");
              //console.log("Remote Pub Key: "+data.pubKey);
              if (keyPair.pubKey == remotePubKey) {
                console.log("Key on remote matches local");
                return callback(null);
              } else {
                console.log("Key on remote does not match");
                //console.log("local pubKey: "+keyPair.pubKey);
                //console.log("remote pubKey: "+remotePubKey);
                updatePubKeyOnRemote(userName, keyPair.pubKey, function(err) {
                  if (err) {
                    console.log("Error updating pubKey on remote");
                    return callback(err);
                  } else {
                    console.log("Updated remote pubKey");
                    return callback(null);
                  }
                });
              }
            }
          }
        });
      };

      function updatePubKeyOnRemote(userName, pubKey, callback) {
        console.log("2 Updating public key on remote");
        $.ajax({
          type: "POST",
          url: "/key/pubkey",
          dataType: "json",
          data: {
            userName: userName,
            pubKey: pubKey
          },
          success: function(data, textStatus, xhr) {
          },
          statusCode: {
            404: function() {
              console.log("Got 404 when updating public key on remote");
              return callback("Error updating public key on remote");
            },
            200: function(data, textStatus, xhr) {
              console.log("Updated remote pubKey successfully");
              return callback(null);
            }
          }
        });
      };

      $('textarea').keydown(function (event) {
        if (event.keyCode == 13 && event.shiftKey) {
          var content = this.value;
          var caret = getCaret(this);
          this.value = content.substring(0,caret)+"\n"+content.substring(caret,content.length);
          event.stopPropagation();
          console.log("got shift+enter");
          var $messageInput = $('#message-input');
          $messageInput[0].scrollTop = $messageInput[0].scrollHeight;
          return false;
        } else if(event.keyCode == 13) {
          console.log("got enter");
          $('form').submit();
          return false;
        }
      });

      $('#mainContainer a').attr('target','_blank');

      function isHidden() {
        var hidden = "hidden";
        // Standards:
        if (hidden in document)
          document.addEventListener("visibilitychange", onchange);
        else if ((hidden = "mozHidden") in document)
          document.addEventListener("mozvisibilitychange", onchange);
        else if ((hidden = "webkitHidden") in document)
          document.addEventListener("webkitvisibilitychange", onchange);
        else if ((hidden = "msHidden") in document)
          document.addEventListener("msvisibilitychange", onchange);
        // IE 9 and lower:
        else if ("onfocusin" in document)
          document.onfocusin = document.onfocusout = onchange;
        // All others:
        else
          window.onpageshow = window.onpagehide
          = window.onfocus = window.onblur = onchange;

        function onchange (evt) {
          var v = "visible", h = "hidden",
              evtMap = {
                focus:v, focusin:v, pageshow:v, blur:h, focusout:h, pagehide:h
              };

          evt = evt || window.event;
          if (evt.type in evtMap)
            document.body.className = evtMap[evt.type];
          else
            document.body.className = this[hidden] ? "hidden" : "visible";
        }

        // set the initial state (but only if browser supports the Page Visibility API)
        if( document[hidden] !== undefined )
          onchange({type: document[hidden] ? "blur" : "focus"});
        if (hidden == "hidden")
          return true;
        else
          return false;
      };

      function getCaret(el) {
        if (el.selectionStart) {
          return el.selectionStart;
        } else if (document.selection) {
          el.focus();
          var r = document.selection.createRange();
          if (r == null) {
            return 0;
          }
          var re = el.createTextRange(),
          rc = re.duplicate();
          re.moveToBookmark(r.getBookmark());
          rc.setEndPoint('EndToStart', re);
          return rc.text.length;
        }
        return 0;
      }

      function localMsg(data) {
        var type = data.type;
        var message = data.message;
        var id = data.id;
        var align = data.align || "left";
        if (type !== null && id !== null) {
          $('#messages').append($('<li id="'+id+'">').html("["+type+"] "+message));
        } else if (type !== null) {
          $('#messages').append($('<li>').html("["+type+"] "+message));
        } else {
          $('#messages').append($('<li>').html(message));
        }
        var $messageInput = $('#message-input');
        $messageInput[0].scrollTop = $messageInput[0].scrollHeight;
      };

      function updateUserList(data, callback) {
        var userList = data.userList;
        var userListHtml = "";
        userList.forEach(function(userName) {
          userListHtml += "<li>"+userName+"</li>\n";
        });
        $('#user-list').html(userListHtml);
        callback(null);
      };

      function prepareMessage(message, callback) {
        var parsedMessage = marked(message);
        var container = $('<div>').html(parsedMessage);
        console.log("Unparsead message: "+container.html());
        // Check the hostname to make sure that it's not a local link...
        container.find('a').attr('target','_blank');
        container.find('code').addClass('hljs');
        console.log("Parsed message: "+container.html());
        callback(null, container.html());
      }
      $('.dropdown')
        .dropdown({
          transition: 'drop'
        })
      ;

      $('#generate-keypair-button').on('click', function() {
        console.log("Regenerating client keypair");
        regenerateClientKeyPair(function(err) {
          console.log("Client keypair regeneration done...");
        });
      });

      $('#select-keypair-button').on('click', function() {
        console.log("Loading keypair from file...");
        promptForImportKeyPair(function(err, data) {
          var privKey = data.privKey;
          var pubKey = data.pubKey;
          updateRemotePubKey(userName, pubKey, function(err) {
            if (err) { return console.log("Error updating remote public key") };
            promptForPassword(function(err) {
              loadClientKeyPairFromFile({ pubKey: pubKey, privKey: privKey }, function(err) {
                if (err) {
                 alertUser("Error loading key pair", err);
                } else {
                  console.log("Done loading keypair from file...");
                  // push new public key to server
                  // wait for encrypted master key
                };
              });
            });
          });
        });
      });

      function promptForImportKeyPair(callback) {
        console.log("Prompting user to import existing keypair");
        $('.basic.modal.import-keypair-modal').modal('show');
        //$('.basic.modal.import-keypair-modal #pubkey-file-input').css('opacity', '0');
        //$('.basic.modal.import-keypair-modal #privkey-file-input').css('opacity', '0');
        $('.import-keypair-modal #select-pubkey').click(function(e) {
          e.preventDefault();
          $('#pubkey-file-input').trigger('click');
        });
        $('.import-keypair-modal #select-privkey').click(function(e) {
          e.preventDefault();
          $('#privkey-file-input').trigger('click');
        });
        $('.import-keypair-submit-button').click(function(e) {
          var pubKeyFile = document.getElementById('pubkey-file-input').files[0];
          var pubKeyContents = null;
          var privKeyFile = document.getElementById('privkey-file-input').files[0];
          var privKeyContents = null;
          if (pubKeyFile && privKeyFile) {
            var reader = new FileReader();
            reader.readAsText(pubKeyFile);
            reader.onload = function(e) {
              pubKeyContents = e.target.result;
              reader.readAsText(privKeyFile);
              reader.onload = function(e) {
                privKeyContents = e.target.result;
                var data = ({
                  pubKey: pubKeyContents,
                  privKey: privKeyContents,
                });
                console.log("Read key files with contents: pubKey: "+pubKeyContents+" privKey: "+privKeyContents);
                callback(null, data);
              };
            };
          } else {
            err = "Error importing key pair from file";
            callback(err, null);
          };
        });
      };

      $('#export-keypair-button').on('click', function() {
        console.log("Exporting keypair to file");

      });


      function promptForPassword(callback) {
        console.log("Showing password prompt modal");
        $('.basic.modal.password-prompt-modal').modal('show');
        $('.password-submit-button').click(function(e) {
          console.log("Got click on password submit button");
          var form = $(this);
          var password = $(".password-prompt-modal input[name='password']").val();
          callback(null, password);
          return false;
        });
        $(document).keypress(function(e) {
          if (e.which == 13) {
            console.log("Got enter key");
            var form = $(this);
            var password = $(".password-prompt-modal input[name='password']").val();
            // hide modul & clear password prompt
            $(".password-prompt-modal input[name='password']").val('');
            $('.basic.modal.password-prompt-modal').modal('hide');
            callback(null, password);
            return false;
          };
        });
      };

      function promptForKeyCredentials(callback) {
        console.log("Showing key creds modal");
        $('.basic.modal.key-creds-modal').modal('show');
        $('.key-creds-submit-button').click(function(err) {
          console.log("Got click for key creds submit button");
          var data = ({
            userName: $(".key-creds-modal input[name='username']").val(),
            fullName: $(".key-creds-modal input[name='fullname']").val(),
            email: $(".key-creds-modal input[name='email']").val()
          });
          return callback(null, data);
        });
        $(document).keypress(function(e) {
          if (e.which == 13) {
            var data = ({
              userName: $(".key-creds-modal input[name='username']").val(),
              fullName: $(".key-creds-modal input[name='fullname']").val(),
              email: $(".key-creds-modal input[name='email']").val()
            });
            return callback(null, data);
          };
        });
      };

      $('form').submit(function(){
        var input = $('#message-input').val();
        var commandRegex = /^\/(.*)$/
        var regexResult = input.match(commandRegex);
        if (input === "") {
          console.log("Empty input");
        } else if (regexResult !== null) {
          // Catch commands here and encrypt data to users as needed
          var command = regexResult[1];
          var splitCommand = command.split(" ");

          // Locally parsed commands
          if (splitCommand[0] == "msg") {
            var toUser = splitCommand[1];
            var fromUser = userName;
            var length = command.length;
            var message = command.split(" ").slice(2, command.length).join(" ");
            // Make sure that to user exists and is signed on
            prepareMessage(message, function(err, preparedMessage) {
              $.ajax({
                type: "GET",
                url: "/key/pubkey",
                dataType: "json",
                data: {
                  userName: toUser
                },
                success: function(data, textStatus, xhr) {
                },
                statusCode: {
                  404: function() {
                    localMsg({ type: "ERROR", message: "Could not find this "+toUser+" that you're talking about..." });
                    return console.log("Could not find public key for "+toUser);
                  },
                  200: function(data, textStatus, xhr) {
                    var toUserPubKey = data.pubKey;
                    console.log("Got public key for "+toUser);
                    encryptMessage(toUserPubKey, preparedMessage, function(err, pgpMessage) {
                      if (err) {
                        return console.log(err);
                      } else {
                        var messageId = getNewMessageId(function(id) {
                          localMsg({ id: id, type: userName+" -> "+toUser, message: preparedMessage });
                          console.log("username: "+userName);
                          socket.emit('privmsg', { id: id, toUser: toUser, message: pgpMessage } );
                          $('#message-input').val('');
                          return console.log("Private message sent...");
                        });
                      };
                    });
                  }
                }
              });
            });
          } else {
            // Not a locally parsed command so sending unencrypted to server (server might should have its own key to decrypt server commands)
            socket.emit('server command', { command: regexResult[1], currentChannel: currentChannel });
            console.log("Sending command '"+regexResult[1]+"' to server");
            $('#message-input').val('');
          };
        } else if (masterKeyPair.pubKey !== null) {
          // Normal message to the current channel
          var pubKey = masterKeyPair.pubKey;
          var message = input;
          console.log("attempting to encrypt message");

          prepareMessage(message, function(err, preparedMessage) {
          //console.log("[DEBUG] pubKey (masterKeyPair.pubKey): "+pubKey);
            encryptMessage(pubKey, preparedMessage, function(err, pgpMessage) {
              if (err) {
                console.log("Error Encrypting Message: "+err);
              } else {
                console.log("Message encrypted successfully");
                // Need to not send the username here and derive it from the socket on the server
                socket.emit('roomMessage', { userName: userName, pgpMessage: pgpMessage } );
                console.log("Message emitted to socket.io");
                $('#message-input').val('');
              }
            });
          });
        } else {
          console.log("masterKeyPair does not exist yet, must get it!");
          console.log("username is: "+userName);
        }
        return false;
      });

      function pleaseWaitOff() {
        $('#message-input').attr('placeHolder', 'Type your message here...');
        $('#send-button').prop('disabled', false);
        $('#loading-icon').remove();
      };

      function pleaseWait() {
        $('#message-input').attr('placeHolder', 'Type your message here...');
        $('#send-button').prop('disabled', false);
        $('#loading-icon').remove();
      };

      function updateMasterKey(callback) {
        getMasterKeyPair(userName, function(err, encMasterKeyPair) {
          if (err) {
            console.log("Error getting master key pair: "+err);
            localMsg({ type: "ERROR", message: "Error getting master key pair" });
            return callback("Error getting master key pair");
          } else {
            pleaseWait();
            localMsg({ type: null, message: "Updated master key pair" });
            console.log("Got master keypair, ready to encrypt/decrypt");
            encryptedMasterKeyPair.pubKey = encMasterKeyPair.pubKey;
            encryptedMasterKeyPair.privKey = encMasterKeyPair.privKey;
            console.log("Ensuring that client keypair exists");
            //console.log("keyPair.privKey at new master key is: "+keyPair.privKey);
            if (typeof keyPair.privKey !== 'undefined' && keyPair.privKey !== null) {
              console.log("[new master key] Client KeyPair exists. Trying to decrypt master key for '"+userName+"'...");
              //console.log("encryptedMasterKeyPair.privKey: "+encryptedMasterKeyPair.privKey);
              //console.log("encryptedMasterKeyPair.pubKey: "+encryptedMasterKeyPair.pubKey);
              decryptMasterKey(userName, keyPair.privKey, encryptedMasterKeyPair.privKey, function(err, key) {
                console.log("(new master key) Caching master private key decrypted");
                masterKeyPair.privKey = key;
                masterKeyPair.pubKey = encMasterKeyPair.pubKey;
                return callback(null);
              });
            } else {
              console.log("Private key does not yet exist so cannot decrypt master key");
              return callback("Private key does not exist");
            };
          };
        });
      };

      socket.on('new master key', function(data) {
        console.log("[SOCKET] 'new master key'");
        getMasterKeyPair(userName, function(err, encMasterKeyPair) {
          if (err) {
            console.log("Error getting master key pair: "+err);
            localMsg({ type: "ERROR", message: "Error getting master key pair" });
          } else {
            localMsg({ type: null, message: "Updated master key pair" });
            console.log("Got master keypair, ready to encrypt/decrypt");
            encryptedMasterKeyPair.pubKey = encMasterKeyPair.pubKey;
            encryptedMasterKeyPair.privKey = encMasterKeyPair.privKey;
            console.log("Ensuring that client keypair exists");
            //console.log("keyPair.privKey at new master key is: "+keyPair.privKey);
            if (typeof keyPair.privKey !== 'undefined' && keyPair.privKey !== null) {
              console.log("(new master key) Trying to decrypt master key...");
              //console.log("encryptedMasterKeyPair.privKey: "+encryptedMasterKeyPair.privKey);
              //console.log("encryptedMasterKeyPair.pubKey: "+encryptedMasterKeyPair.pubKey);
              decryptMasterKey(userName, keyPair.privKey, encryptedMasterKeyPair.privKey, function(err, key) {
                console.log("(new master key) Caching master private key decrypted");
                masterKeyPair.privKey = key;
                masterKeyPair.pubKey = encMasterKeyPair.pubKey;
                pleaseWaitOff();
              });
            } else {
              console.log("Private key does not yet exist so cannot decrypt master key");
            };
          };
        });
      });

      socket.on('chat status', function(data) {
        console.log("Got chat status...");
        var statusType = data.statusType;
        var statusMessage = data.statusMessage;
        localMsg({ type: statusType, message: statusMessage });
        var $messages = $('#messages');
        $messages[0].scrollTop = $messages[0].scrollHeight;
      });

      socket.on('join', function(data) {
        var channel = data.channel;
        var joinUser = data.joinUser;
        sendNotification(null, 'PiPo', joinUser+' has joined channel #'+channel, 3000);
      });

      socket.on('privmsg', function(data) {
        var fromUser = data.fromUser;
        var toUser = data.toUser;
        var pgpMessage = data.message;
        var id = data.id;
        decryptMessage(keyPair.privKey, clientKeyPassword, pgpMessage, function(err, message) {
          localMsg({ id: id, type: fromUser+" -> "+toUser, message: message });
          var $messageInput = $('#message-input');
          $messageInput[0].scrollTop = $messageInput[0].scrollHeight;
          sendNotification(null, 'Private Message from '+fromUser, $(message).text(), 3000);
        });
      });

      socket.on('roomMessage', function(data){
        console.log("Just got chat message!");
        var fromUser = data.userName;
        var pgpMessage = data.pgpMessage;
        //console.log("Got message, attempting to decrypt");
        decryptMessage(masterKeyPair.privKey, masterKeyPassword, pgpMessage, function(err, message) {
          console.log("Decrypting master private key with password '"+masterKeyPassword+"'");
          //console.log("inside decrypt message callback");
          if (err) {
            console.log("ERROR Decrypting message: "+err);
          } else {
            //console.log("Message decrypted! - '"+message+"'");
            //var sanatizedMessage = sanatize(message);
            console.log("raw message is: "+message);
            var messages = $('#messages');
            var messageLine = "["+fromUser+"] "+message;
            localMsg({ type: null, message: messageLine });
            messages[0].scrollTop = messages[0].scrollHeight;
            var regexResult = new RegExp('@'+userName, 'i').exec(message);
            //var mentionRegex = /@<%= userName %>/;
            //var regexResult = message.match(mentionRegex);
            if (regexResult !== null) {
              sendNotification(null, fromUser+' mentioned you...', $(message).text(), 3000);
            }
          }
        });
      });

      socket.on('userlist update', function(data) {
        var userList = data.userList;
        var joinUser = data.joinUser;
        var channel = data.channel;
        console.log("[USERLIST UPDATE] Got userlist update of "+userList.toString());
        updateUserList({ userList: userList }, function(err) {
          if (err) return console.log("Error updating user list: "+err);
          if (typeof joinUser !== 'undefined') {
            sendNotification(null, 'PiPo', joinUser+' has joined channel #'+channel, 3000);
            console.log("UserList update successful...");
          };
        });
      });

      function getNewMessageId(callback) {
        var id = new Date().getTime();
        callback(id);
      };

      function generateKeyPair(numBits, userId, passphrase, callback) {
        var options = {
          numBits: numBits,
          userId: userId,
          passphrase: passphrase
        }
        console.log("Generating keypair, please wait...");
        window.openpgp.generateKeyPair(options).then(function(keyPair) {
          var privKey = keyPair.privateKeyArmored;
          var pubKey = keyPair.publicKeyArmored;
          keyPair = {
            privKey: privKey,
            pubKey: pubKey
          }
          return callback(null, keyPair);
        }).catch(function(err) {
          return callback(err, null);
        });
      };

      function encryptMessage(key, message, callback) {
        var masterPubKey = openpgp.key.readArmored(key);
        openpgp.encryptMessage(masterPubKey.keys, message).then(function(pgpMessage) {
          callback(null, pgpMessage);
        }).catch(function(error) {
          return callback(error, null);
        });
      };

      function decryptMessage(key, passphrase, pgpMessage, callback) {
        var masterPrivateKey = openpgp.key.readArmored(key).keys[0];
        if (typeof masterPrivateKey !== 'undefined') {
          masterPrivateKey.decrypt(passphrase);
          pgpMessage = openpgp.message.readArmored(pgpMessage);
          openpgp.decryptMessage(masterPrivateKey, pgpMessage).then(function(plaintext) {
            console.log("Decrypted message!");
            callback(null, plaintext);
          }).catch(function(err) {
            console.log("Error decrypting message");
            return callback(err, null);
          });
        } else {
          console.log("master private key is undefined!");
          return callback("master private key is undefined", null);
        }
      }

      var rAmp = /&/g,
        rLt = /</g,
        rGt = />/g,
        rApos =/\'/g,
        rQuot = /\"/g,
        hChars =/[&<>\"\']/;

      function coerceToString(val) {
        return String((val === null || val === undefined) ? '' : val);
      }

      function sanatize(str) {
        str = coerceToString(str);

        return hChars.test(str)
          ? str
            .replace(rAmp,'&amp;')
            .replace(rLt,'&lt;')
            .replace(rGt,'&gt;')
            .replace(rApos,'&#39;')
            .replace(rQuot, '&quot;')
          : str;
      };

      // Sends a notification that expires after a timeout. If timeout = 0 it does not expire
      function sendNotification(image, title, message, timeout, showOnFocus) {
        getNotifyPermissions(function(permission) {
          if (permission) {
            console.log("[NOTIFICATION] Attempting to display notification");
            // Default values for optional params
            timeout = (typeof timeout !== 'undefined') ? timeout : 0;
            showOnFocus = (typeof showOnFocus !== 'undefined') ? showOnFocus : false;
            // Check if the browser window is focused
            var isWindowFocused = document.querySelector(":focus") === null ? false : true;
            // Check if we should send the notification based on the showOnFocus parameter
            var shouldNotify = !isWindowFocused || isWindowFocused && showOnFocus;
            console.log("[NOTIFICATION] shouldNotify is "+shouldNotify);
            if (shouldNotify) {
              // Create the notification object
              //var notification = window.webkitNotifications.createNotification(
              //  image, title, message
              //);
              // Display the notification
              //notification.show();
              console.log("[NOTIFACTION] Sending notification now...");
              var notification = new Notification(title, { body: message });
              if (timeout > 0) {
                // Hide the notification after the timeout
                setTimeout(function(){
                  notification.close()
                }, timeout);
              }
            }
          } else {
            console.log("Don't have permission to display notification");
          }
        });
      };

      function getNotifyPermissions(callback) {
        // check for notification compatibility
        if(!window.Notification) {
          // if browser version is unsupported, be silent
          return callback(false);
        }
        // log current permission level
        console.log(Notification.permission);
        // if the user has not been asked to grant or deny notifications from this domain
        if(Notification.permission === 'default') {
          Notification.requestPermission(function() {
            // callback this function once a permission level has been set
            return callback(true);
          });
        }
        // if the user has granted permission for this domain to send notifications
        else if(Notification.permission === 'granted') {
          return callback(true);
        }
        // if the user does not want notifications to come from this domain
        else if(Notification.permission === 'denied') {
          return callback(false);
        }
      };
    </script>


  </body>
</html>
