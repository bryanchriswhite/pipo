<!doctype html>
<html>
  <head>
    <title>PiPo</title>
  </head>
  <body>
    <div id="mainContainer">
      <ul id="messages">
      </ul>
      <div id="menu">
        <div id="left-menu-profile">
        </div>
        <div id="left-menu-scroll">
          <div id="room-list-container">
            <h5 class="room-list-header">Rooms</h5>
            <ul id="room-list">
              <li class="room-list-item">#general</li>
            </ul>
          </div>
          <div id="user-list-container">
            <h5 class="user-list-header">Users</h5>
            <div id="user-list">
            </div>
          </div>
        </div>
        <div id="menu-actions">
          <a class="button-create-room" href="#createroom">Create a room</a>
        </div>
      </div>
    </div>
    <div class="input-container" id="input-container">
      <form>
        <div id="message-input-container" class="ui left fluid action icon input loading">
          <textarea id="message-input" class="message-input ui left icon loading" autocorrect="off" spellcheck="true" autocomplete="off" type="text" placeholder="          Please wait while your secure connection is configured..."></textarea>
          <i id="loading-icon" class="search icon"></i>
          <button id="send-button" class="ui button" disabled="true">Send</button>
        </div>
      </form>
    </div>
    <link rel="stylesheet" href="/css/semantic.css">
    <link rel="stylesheet" href="/css/pipo.css">
    <link rel="stylesheet" href="/css/highlight.js/styles/default.css">

    <script src="/js/openpgp.js"></script>
    <script src="http://code.jquery.com/jquery-1.11.1.js"></script>
    <script src="/js/semantic.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script src="js/marked.js"></script>

<script src="https://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

    <script>
      marked.setOptions({
        renderer: new marked.Renderer(),
        gfm: true,
        tables: true,
        breaks: true,
        pedantic: false,
        sanatize: true,
        smartLists: true,
        smartypants: false,
        highlight: function (code) {
          return hljs.highlightAuto(code).value;
        }
      });
      var host = window.location.host;
      var socket = io(host+'/main');
      var currentChannel = "general";
      var clientKeyPairPassphrase = "superawesomepasswordhere";
      var keyPair = ({
        pubKey: null,
        privKey: null
      });
      var encryptedMasterKeyPair = ({
        pubKey: null,
        privKey: null
      });
      var masterKeyPair = ({
        pubKey: null,
        privKey: null
      });
      var userName = "<%= userName %>";
      start();
      function start() {
        openpgp.initWorker('/js/openpgp.worker.js');
        var statusType = "STATUS";
        var statusMessage = "Please wait while your keys are prepared...";
        $('#messages').append($('<li>').text("["+statusType+"] "+statusMessage));
        socket.emit('init', { userName: userName });
        generateClientKeyPair(2048, "<%= userName %>", clientKeyPairPassphrase, function(err, generatedKeyPair) {
          if (err) {
            console.log("Error generating client keypair: "+err);
          } else {
            console.log("Generated client key pair.");
            var statusType = "STATUS";
            var statusMessage = "Client keys generated.";
            $('#messages').append($('<li>').text("["+statusType+"] "+statusMessage));
            keyPair = generatedKeyPair;
              var statusType = "STATUS";
              var statusMessage = "Waiting for MASTER key from server...";
              $('#messages').append($('<li>').text("["+statusType+"] "+statusMessage));
            updateRemotePubKey("<%= userName %>", keyPair.pubKey, function(err) {
              console.log("Remote keyPair check done.");
              if (err) {
                return console.log("Error when checking for remote public key: "+err);
              } else {
              // Get master key if we don't have it locally
                console.log("[START] Joining channel #general");
                socket.emit('join', { userName: userName, channel: "general" } );
              };
            });
          }
        });
      };

      function decryptMasterKey(userName, privKey, encryptedMasterPrivateKey, callback) {
        var encMasterPrivateKey = openpgp.message.readArmored(encryptedMasterPrivateKey);
        var clientPrivKey = openpgp.key.readArmored(privKey).keys[0];
        clientPrivKey.decrypt(clientKeyPairPassphrase);
        //console.log("[DEBUG] (decryptMasterKey) values - userName: "+userName+" privKey: "+clientPrivKey+" encMasterPrivateKey: "+encMasterPrivateKey);
        console.log("[DEBUG] about to start decrypting master key");
        openpgp.decryptMessage(clientPrivKey, encMasterPrivateKey).then(function(decryptedKey) {
          console.log("[DEBUG] in decryptMessage callback");
          //console.log("decrypted key in decryptMaster Key is: "+decryptedKey);
          callback(null, decryptedKey);
        }).catch(function(err) {
          console.log("[DEBUG] error decrypting message: "+err);
          if (err) { callback(err, null); };
        });
      };

      function getMasterKeyPair(userName, callback) {
        var timestamp = new Date().toString();
        console.log("["+timestamp+"] Getting master keyPair for "+userName);
        $.ajax({
          type: "GET",
          url: "/key/masterKeyPair",
          dataType: "json",
          data: {
            userName: userName
          },
          statusCode: {
            404: function(err) {
              console.log("["+timestamp+"] [MASTER KEY PAIR] (404) Error getting master keypair: "+err);
              return callback(err, null);
            },
            200: function(data) {
              console.log("["+timestamp+"] [MASTER KEY PAIR] (200) Encrypted masterKeyPair retrieved and cached");
              return callback(null, data);
            }
          }
        });
      };

      function updateRemotePubKey(userName, pubKey, callback) {
        console.log("Updating remote public key");
        $.ajax({
          type: "GET",
          url: "/key/pubkey",
          dataType: "json",
          data: {
            userName: userName
          },
          statusCode: {
            404: function(err) {
              console.log("No key found on remote");
              updatePubKeyOnRemote(userName, keyPair.pubKey, function(err) {
                console.log("1 Updating public key on remote");
                if (err) {
                  console.log("Error updating pubKey on remote");
                  return callback(err);
                } else {
                  console.log("Updated remote pubKey");
                    return callback(null);
                }
              });
            },
            200: function(data) {
              console.log("[DEBUG] (updateRemotePubKey) data: "+data);
              var remotePubKey = data.pubKey;
              console.log("Key exists on remote");
              if (keyPair.pubKey == remotePubKey) {
                console.log("Key on remote matches local");
                return callback(null);
              } else {
                console.log("Key on remote does not match");
                updatePubKeyOnRemote(userName, keyPair.pubKey, function(err) {
                  if (err) {
                    console.log("Error updating pubKey on remote");
                    return callback(err);
                  } else {
                    console.log("Updated remote pubKey");
                    return callback(null);
                  }
                });
              }
            }
          }
        });
      };

      function updatePubKeyOnRemote(userName, pubKey, callback) {
        console.log("2 Updating public key on remote");
        $.ajax({
          type: "POST",
          url: "/key/pubkey",
          dataType: "json",
          data: {
            userName: userName,
            pubKey: pubKey
          },
          success: function(data, textStatus, xhr) {
          },
          statusCode: {
            404: function() {
              console.log("Got 404 when updating public key on remote");
              return callback("Error updating public key on remote");
            },
            200: function(data, textStatus, xhr) {
              console.log("Updated remote pubKey successfully");
              return callback(null);
            }
          }
        });
      };

      $('textarea').keydown(function (event) {
        if (event.keyCode == 13 && event.shiftKey) {
          var content = this.value;
          var caret = getCaret(this);
          this.value = content.substring(0,caret)+"\n"+content.substring(caret,content.length);
          event.stopPropagation();
          console.log("got shift+enter");
          var $messageInput = $('#message-input');
          $messageInput[0].scrollTop = $messageInput[0].scrollHeight;
          return false;
        } else if(event.keyCode == 13) {
          console.log("got enter");
          $('form').submit();
          return false;
        }
      });

      $('#mainContainer a').attr('target','_blank');

      function getCaret(el) {
        if (el.selectionStart) {
          return el.selectionStart;
        } else if (document.selection) {
          el.focus();
          var r = document.selection.createRange();
          if (r == null) {
            return 0;
          }
          var re = el.createTextRange(),
          rc = re.duplicate();
          re.moveToBookmark(r.getBookmark());
          rc.setEndPoint('EndToStart', re);
          return rc.text.length;
        }
        return 0;
      }

      function localMsg(data) {
        var type = data.type;
        var message = data.message;
        var id = data.id;
        if (type !== null && id !== null) {
          $('#messages').append($('<li id="'+id+'">').html("["+type+"] "+message));
        } else if (type !== null) {
          $('#messages').append($('<li>').html("["+type+"] "+message));
        } else {
          $('#messages').append($('<li>').html(message));
        }
      };

      function updateUserList(data, callback) {
        var userList = data.userList;
        var userListHtml = "";
        userList.forEach(function(userName) {
          userListHtml += "<li>"+userName+"</li>\n";
        });
        $('#user-list').html(userListHtml);
        callback(null);
      };

      function prepareMessage(message, callback) {
        var parsedMessage = marked(message);
        var container = $('<div>').html(parsedMessage);
        console.log("Unparsead message: "+container.html());
        // Check the hostname to make sure that it's not a local link...
        container.find('a').attr('target','_blank');
        container.find('code').addClass('hljs');
        console.log("Parsed message: "+container.html());
        callback(null, container.html());
      }

      $('form').submit(function(){
        var input = $('#message-input').val();
        var userName = "<%= userName %>";
        var commandRegex = /^\/(.*)$/
        var regexResult = input.match(commandRegex);
        if (input === "") {
          console.log("Empty input");
        } else if (regexResult !== null) {
          // Catch commands here and encrypt data to users as needed
          var command = regexResult[1];
          var splitCommand = command.split(" ");

          // Locally parsed commands
          if (splitCommand[0] == "msg") {
            var toUser = splitCommand[1];
            var fromUser = userName;
            var length = command.length;
            var message = command.split(" ").slice(2, command.length).join(" ");
            // Make sure that to user exists and is signed on
            prepareMessage(message, function(err, preparedMessage) {
              $.ajax({
                type: "GET",
                url: "/key/pubkey",
                dataType: "json",
                data: {
                  userName: toUser
                },
                success: function(data, textStatus, xhr) {
                },
                statusCode: {
                  404: function() {
                    console.log("Got 404 when finding pubKey for "+userName);
                    return callback("Error finding public key for "+userName);
                  },
                  200: function(data, textStatus, xhr) {
                    var toUserPubKey = data.pubKey;
                    console.log("Got public key for "+userName);
                    encryptMessage(toUserPubKey, preparedMessage, function(err, pgpMessage) {
                      if (err) {
                        return console.log(err);
                      } else {
                        var messageId = getNewMessageId(function(id) {
                          localMsg({ id: id, type: userName+" -> "+toUser, message: preparedMessage });
                          console.log("username: "+userName);
                          socket.emit('privmsg', { id: id, toUser: toUser, message: pgpMessage } );
                          $('#message-input').val('');
                          return console.log("Private message sent...");
                        });
                      };
                    });
                  }
                }
              });
            });
          } else {
            // Not a locally parsed command so sending unencrypted to server (server might should have its own key to decrypt server commands)
            socket.emit('server command', { command: regexResult[1], currentChannel: currentChannel });
            console.log("Sending command '"+regexResult[1]+"' to server");
            $('#message-input').val('');
          };
        } else if (masterKeyPair.pubKey !== null) {
          // Normal message to the current channel
          var pubKey = masterKeyPair.pubKey;
          var userName = "<%= userName %>";
          var message = input;
          console.log("attempting to encrypt message");

          prepareMessage(message, function(err, preparedMessage) {
          //console.log("[DEBUG] pubKey (masterKeyPair.pubKey): "+pubKey);
            encryptMessage(pubKey, preparedMessage, function(err, pgpMessage) {
              if (err) {
                console.log("Error Encrypting Message: "+err);
              } else {
                console.log("Message encrypted successfully");
                // Need to not send the username here and derive it from the socket on the server
                socket.emit('chat message', { userName: userName, pgpMessage: pgpMessage } );
                console.log("Message emitted to socket.io");
                $('#message-input').val('');
              }
            });
          });
        } else {
          console.log("masterKeyPair does not exist yet, must get it!");
          var userName = "<%= userName %>";
          console.log("username is: "+userName);
        }
        return false;
      });

      socket.on('new master key', function(data) {
        console.log("Getting master keyPair for "+userName);
        getMasterKeyPair(userName, function(err, encMasterKeyPair) {
          if (err) {
            console.log("Error getting master key pair: "+err);
            localMsg({ type: "ERROR", message: "Error getting master key pair" });
          } else {
            localMsg({ type: null, message: "Updated master key pair" });
            console.log("Got master keypair, ready to encrypt/decrypt");
            encryptedMasterKeyPair.pubKey = encMasterKeyPair.pubKey;
            encryptedMasterKeyPair.privKey = encMasterKeyPair.privKey;
            console.log("Ensuring that client keypair exists");
            //console.log("keyPair.privKey at new master key is: "+keyPair.privKey);
            if (typeof keyPair.privKey !== 'undefined' && keyPair.privKey !== null) {
              console.log("(new master key) Trying to decrypt master key...");
              decryptMasterKey(userName, keyPair.privKey, encryptedMasterKeyPair.privKey, function(err, key) {
                console.log("(new master key) Caching master private key decrypted");
                masterKeyPair.privKey = key;
                masterKeyPair.pubKey = encMasterKeyPair.pubKey;
                $('#message-input').attr('placeHolder', 'Type your message here...');
                $('#send-button').prop('disabled', false);
                $('#loading-icon').remove();
              });
            } else {
              console.log("Private key does not yet exist so cannot decrypt master key");
            };
          };
        });
      });

      socket.on('chat status', function(data) {
        console.log("Got chat status...");
        var statusType = data.statusType;
        var statusMessage = data.statusMessage;
        localMsg({ type: statusType, message: statusMessage });
        var $messages = $('#messages');
        $messages[0].scrollTop = $messages[0].scrollHeight;
      });

      socket.on('privmsg', function(data) {
        var fromUser = data.fromUser;
        var toUser = data.toUser;
        var pgpMessage = data.message;
        var id = data.id;
        decryptMessage(keyPair.privKey, clientKeyPairPassphrase, pgpMessage, function(err, message) {
          localMsg({ id: id, type: fromUser+" -> "+toUser, message: message });
        });
      });

      socket.on('chat message', function(data){
        console.log("Just got chat message!");
        var userName = data.userName;
        var pgpMessage = data.pgpMessage;
        //console.log("Got message, attempting to decrypt");
        decryptMessage(masterKeyPair.privKey, "pipo", pgpMessage, function(err, message) {
          //console.log("inside decrypt message callback");
          if (err) {
            console.log("ERROR Decrypting message: "+err);
          } else {
            //console.log("Message decrypted! - '"+message+"'");
            //var sanatizedMessage = sanatize(message);
            console.log("raw message is: "+message);
            var messages = $('#messages');
            var messageLine = "["+userName+"] "+message;
            localMsg({ type: null, message: messageLine });
            messages[0].scrollTop = messages[0].scrollHeight;
          }
        });
      });

      socket.on('userlist update', function(data) {
        var userList = data.userList;
        console.log("[USERLIST UPDATE] Got userlist update of "+userList.toString());
        updateUserList({ userList: userList }, function(err) {
          if (err) return console.log("Error updating user list: "+err);
          console.log("UserList update successful...");
        });
      });

      function getNewMessageId(callback) {
        var id = new Date().getTime();
        callback(id);
      };

      function generateClientKeyPair(numBits, userId, passphrase, callback) {
        var options = {
          numBits: numBits,
          userId: userId,
          passphrase: passphrase
        }
        console.log("Generating client keypair, please wait...");
        window.openpgp.generateKeyPair(options).then(function(keyPair) {
          var privKey = keyPair.privateKeyArmored;
          var pubKey = keyPair.publicKeyArmored;
          keyPair = {
            privKey: privKey,
            pubKey: pubKey
          }
          return callback(null, keyPair);
        }).catch(function(err) {
          return callback(err, null);
        });
      };

      function encryptMessage(key, message, callback) {
        var masterPubKey = openpgp.key.readArmored(key);
        openpgp.encryptMessage(masterPubKey.keys, message).then(function(pgpMessage) {
          callback(null, pgpMessage);
        }).catch(function(error) {
          return callback(error, null);
        });
      };

      function decryptMessage(key, passphrase, pgpMessage, callback) {
        var masterPrivateKey = openpgp.key.readArmored(key).keys[0];
        if (typeof masterPrivateKey !== 'undefined') {
          masterPrivateKey.decrypt(passphrase);
          pgpMessage = openpgp.message.readArmored(pgpMessage);
          openpgp.decryptMessage(masterPrivateKey, pgpMessage).then(function(plaintext) {
            console.log("Decrypted message!");
            callback(null, plaintext);
          }).catch(function(err) {
            console.log("Error decrypting message");
            return callback(err, null);
          });
        } else {
          console.log("master private key is undefined!");
          return callback("master private key is undefined", null);
        }
      }

      var rAmp = /&/g,
        rLt = /</g,
        rGt = />/g,
        rApos =/\'/g,
        rQuot = /\"/g,
        hChars =/[&<>\"\']/;

      function coerceToString(val) {
        return String((val === null || val === undefined) ? '' : val);
      }

      function sanatize(str) {
        str = coerceToString(str);

        return hChars.test(str)
          ? str
            .replace(rAmp,'&amp;')
            .replace(rLt,'&lt;')
            .replace(rGt,'&gt;')
            .replace(rApos,'&#39;')
            .replace(rQuot, '&quot;')
          : str;
      };
    </script>
  </body>
</html>
